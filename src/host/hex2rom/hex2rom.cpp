/**
 * @file   hex2rom.cpp
 * @author Lukas Schuller
 * @date   Sun Apr 27 23:51:06 2014
 * 
 * @brief  
 * 
 * @license 
 *  Copyright (C) 2014 Lukas Schuller
 * 
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 * 
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#include "../nfcemu/IntelHexFile.h"

#include <iostream>

using namespace std;

string ByteToBin(unsigned char const c) {
    string str(8, '0');
    for(size_t i = 0; i < 8; ++i) {
        str[i] = (c & (1 << (7-i))) ? '1' : '0';
    }
    return str;
}

int main(int argc, char * argv[]) {

    if(argc < 5) {
        cout << "Usage: hex2rom foo.ihx 12 8 bar" << endl
             << "where foo is the hex file name, 12 is the " << endl
             << "rom address width, 8 is the data width and bar " << endl
             << "is the name of the generated entity/file" << endl
             << "This program was inspired by hex2rom by Daniel Wallner" << endl
             << "(c) 2014 Lukas Schuller" << endl
             << "License: GPLv3 or compatible" << endl;
          
        return -1;
    }

    string hexFile(argv[1]);
    size_t adrWidth = stoul(argv[2]);
    size_t dataWidth = stoul(argv[3]);

    if(dataWidth % 8) {
        cout << "Error: data width must be multiple of 8" << endl;
        return -1;
    }

    if(!dataWidth) {
        cout << "Error: data width must be >= 8" << endl;
        return -1;
    }

    string entityName(argv[4]);
    IntelHexFile ihex(hexFile);
    vector<unsigned char> image;
    ihex.GetImage(back_inserter(image));

    size_t nBytes = dataWidth/8;

    if( (1 << adrWidth)/nBytes < image.size()) {
        cout << "Warning: image size is bigger than address space, will be truncated" << endl;
    }


    ofstream of(entityName + ".vhd");

    of << "-- generated by hex2rom (c) 2014 Lukas Schuller\n\n"
       << "library IEEE;\n"
       << "use IEEE.std_logic_1164.all;\n"
       << "use IEEE.numeric_std.all;\n\n"
       << "entity " << entityName << " is" << endl
       << "	port(\n"
       << "		Clk	: in std_ulogic;\n"
       << "		A	: in std_ulogic_vector(" << adrWidth-1 << " downto 0);\n"
       << "		D	: out std_ulogic_vector(" << dataWidth-1 << " downto 0)\n"
       << "	);\n"
       << "end " << entityName << ";\n"
       << "\n"
       << "architecture rtl of " << entityName << " is\n"
       << "	attribute romstyle : string;\n"
       << "	attribute romstyle of rtl : architecture is \"M4K\";\n"
       << "begin\n"
       << "	process (Clk)\n"
       << "	begin\n"
       << "		if rising_edge(Clk) then\n"
       << "			case to_integer(unsigned(A)) is\n";


    for(size_t i = 0; i < image.size(); i+=nBytes) {
        string valStr;
        for(int j = nBytes-1; j >= 0; --j) {
            valStr += ByteToBin(image[i+j]);
        }

        of << "			    when " << setfill('0') << setw(6) << (i/nBytes) 
           << " => D <= \"" << valStr << "\";\n";

            
    }


    of << "				when others => D <= \"00000000\";\n"
       << "			end case;\n"
       << "		end if;\n"
       << "	end process;\n"
       << "end;\n";

    of.close();

    return 0;
}
